/**
 * Contract Error Registry Generator
 *
 * Scans all compiled contract artifacts and generates a comprehensive
 * error registry for user-friendly error message display.
 *
 * Usage: npx ts-node scripts/generate-error-registry.ts
 *
 * Output: WebApp/src/utils/contractErrorRegistry.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { keccak256, toUtf8Bytes } from 'ethers';

interface ErrorDefinition {
  name: string;
  signature: string;
  selector: string;
  parameters: Array<{ name: string; type: string }>;
  contracts: string[];
}

interface AbiItem {
  type: string;
  name?: string;
  inputs?: Array<{ name: string; type: string; internalType?: string }>;
}

/**
 * Recursively find all JSON artifact files
 */
function findArtifactFiles(dir: string): string[] {
  const files: string[] = [];

  try {
    const items = fs.readdirSync(dir, { withFileTypes: true });

    for (const item of items) {
      const fullPath = path.join(dir, item.name);

      if (item.isDirectory()) {
        files.push(...findArtifactFiles(fullPath));
      } else if (item.name.endsWith('.json') && !item.name.endsWith('.dbg.json')) {
        files.push(fullPath);
      }
    }
  } catch {
    // Directory doesn't exist or isn't readable
  }

  return files;
}

/**
 * Extract errors from a contract artifact
 */
function extractErrors(filePath: string): Map<string, ErrorDefinition> {
  const errors = new Map<string, ErrorDefinition>();

  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const artifact = JSON.parse(content) as { abi?: AbiItem[]; contractName?: string };

    if (!artifact.abi) {
      return errors;
    }

    const contractName = artifact.contractName ?? path.basename(filePath, '.json');

    for (const item of artifact.abi) {
      if (item.type !== 'error' || !item.name) {
        continue;
      }

      const parameters = (item.inputs ?? []).map((input) => ({
        name: input.name,
        type: input.type,
      }));

      const types = parameters.map((p) => p.type).join(',');
      const signature = `${item.name}(${types})`;
      const selector = keccak256(toUtf8Bytes(signature)).slice(0, 10);

      const existing = errors.get(selector);
      if (existing) {
        // Same error used in multiple contracts
        if (!existing.contracts.includes(contractName)) {
          existing.contracts.push(contractName);
        }
      } else {
        errors.set(selector, {
          name: item.name,
          signature,
          selector,
          parameters,
          contracts: [contractName],
        });
      }
    }
  } catch {
    // Failed to parse artifact
  }

  return errors;
}

/**
 * Generate TypeScript code for the error registry
 */
function generateTypeScript(errors: Map<string, ErrorDefinition>): string {
  const sortedErrors = Array.from(errors.values()).sort((a, b) =>
    a.name.localeCompare(b.name)
  );

  const lines: string[] = [
    '/**',
    ' * Contract Error Registry',
    ' *',
    ' * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY',
    ' * Generated by: Coin/scripts/generate-error-registry.ts',
    ` * Generated at: ${new Date().toISOString()}`,
    ' *',
    ' * This file contains all custom error selectors from OmniBazaar smart contracts.',
    ' * Each error is mapped to its name, signature, and the contracts that use it.',
    ' */',
    '',
    'export interface ContractError {',
    '  /** Error name (e.g., "AlreadyRegistered") */',
    '  name: string;',
    '  /** Full signature with types (e.g., "AlreadyRegistered()") */',
    '  signature: string;',
    '  /** 4-byte selector (e.g., "0x3a81d6fc") */',
    '  selector: string;',
    '  /** Parameter definitions */',
    '  parameters: Array<{ name: string; type: string }>;',
    '  /** Contracts that define this error */',
    '  contracts: string[];',
    '}',
    '',
    '/**',
    ' * Registry of all contract errors by selector',
    ' */',
    'export const CONTRACT_ERROR_REGISTRY: Record<string, ContractError> = {',
  ];

  for (const error of sortedErrors) {
    const paramsStr = JSON.stringify(error.parameters);
    const contractsStr = JSON.stringify(error.contracts);

    lines.push(`  // ${error.signature}`);
    lines.push(`  '${error.selector}': {`);
    lines.push(`    name: '${error.name}',`);
    lines.push(`    signature: '${error.signature}',`);
    lines.push(`    selector: '${error.selector}',`);
    lines.push(`    parameters: ${paramsStr},`);
    lines.push(`    contracts: ${contractsStr},`);
    lines.push('  },');
    lines.push('');
  }

  lines.push('};');
  lines.push('');
  lines.push('/**');
  lines.push(' * Lookup error by selector');
  lines.push(' */');
  lines.push('export function getErrorBySelector(selector: string): ContractError | undefined {');
  lines.push('  return CONTRACT_ERROR_REGISTRY[selector.toLowerCase()];');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Lookup error by name');
  lines.push(' */');
  lines.push('export function getErrorByName(name: string): ContractError | undefined {');
  lines.push('  return Object.values(CONTRACT_ERROR_REGISTRY).find((e) => e.name === name);');
  lines.push('}');
  lines.push('');
  lines.push(`/** Total number of registered errors */`);
  lines.push(`export const ERROR_COUNT = ${sortedErrors.length};`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Main execution
 */
function main(): void {
  console.log('Contract Error Registry Generator');
  console.log('=================================\n');

  const artifactsDir = path.join(__dirname, '..', 'artifacts', 'contracts');
  console.log(`Scanning: ${artifactsDir}\n`);

  const files = findArtifactFiles(artifactsDir);
  console.log(`Found ${files.length} artifact files\n`);

  const allErrors = new Map<string, ErrorDefinition>();

  for (const file of files) {
    const errors = extractErrors(file);
    for (const [selector, error] of errors) {
      const existing = allErrors.get(selector);
      if (existing) {
        // Merge contracts
        for (const contract of error.contracts) {
          if (!existing.contracts.includes(contract)) {
            existing.contracts.push(contract);
          }
        }
      } else {
        allErrors.set(selector, error);
      }
    }
  }

  console.log(`Extracted ${allErrors.size} unique errors\n`);

  // Generate TypeScript
  const tsContent = generateTypeScript(allErrors);

  // Write to WebApp
  const outputPath = path.join(
    __dirname,
    '..',
    '..',
    'WebApp',
    'src',
    'utils',
    'contractErrorRegistry.ts'
  );

  fs.writeFileSync(outputPath, tsContent, 'utf8');
  console.log(`Generated: ${outputPath}`);

  // Also print a summary
  console.log('\nError Summary by Contract:');
  console.log('--------------------------');

  const byContract = new Map<string, string[]>();
  for (const error of allErrors.values()) {
    for (const contract of error.contracts) {
      const list = byContract.get(contract) ?? [];
      list.push(error.name);
      byContract.set(contract, list);
    }
  }

  const sortedContracts = Array.from(byContract.entries()).sort((a, b) =>
    a[0].localeCompare(b[0])
  );

  for (const [contract, errorNames] of sortedContracts) {
    console.log(`  ${contract}: ${errorNames.length} errors`);
  }

  console.log('\nDone!');
}

main();
