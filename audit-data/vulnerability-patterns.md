# Smart Contract Vulnerability Patterns Reference

> Compiled from DeFiVulnLabs (52 types), kadenzipfel/smart-contract-vulnerabilities (37 types),
> SWC Registry, and Trail of Bits not-so-smart-contracts. Deduplicated into 56 distinct patterns.
> Each includes detection heuristics, vulnerable/fixed code, and real-world examples.

---

## Category 1: Reentrancy

### VP-01: Classic Reentrancy
**Classification:** SWC-107 | OWASP SC-08 | Cyfrin SOL-AM-RE
**Severity:** Critical
**Prevalence:** 89+ real exploits in DeFiHackLabs (13% of all incidents)

**Detection Heuristics:**
- External call (`.call{value:}`, `.transfer`, `.send`) BEFORE state update
- Missing `ReentrancyGuard` / `nonReentrant` modifier on functions with ETH/token transfers
- State variable updated after `call` returns

**Vulnerable Pattern:**
```solidity
function withdraw() public {
    uint amount = balances[msg.sender];
    (bool ok,) = msg.sender.call{value: amount}("");
    require(ok);
    balances[msg.sender] = 0; // state update AFTER call
}
```

**Fixed Pattern:**
```solidity
function withdraw() public nonReentrant {
    uint amount = balances[msg.sender];
    balances[msg.sender] = 0; // state update BEFORE call
    (bool ok,) = msg.sender.call{value: amount}("");
    require(ok);
}
```

**Real-World Example:** The DAO (2016-06) — $60M — recursive call in splitDAO drained funds

---

### VP-02: Cross-Function Reentrancy
**Classification:** SWC-107 variant | OWASP SC-08
**Severity:** Critical
**Prevalence:** Included in reentrancy count above

**Detection Heuristics:**
- Two functions share the same state variable
- One function makes an external call, the other reads/writes the shared state
- No reentrancy guard protecting both functions

**Vulnerable Pattern:**
```solidity
function withdraw() public {
    uint amount = balances[msg.sender];
    (bool ok,) = msg.sender.call{value: amount}("");
    require(ok);
    balances[msg.sender] = 0;
}
function transfer(address to, uint amt) public {
    require(balances[msg.sender] >= amt);
    balances[msg.sender] -= amt;
    balances[to] += amt;
}
```

**Fixed Pattern:**
```solidity
// Use nonReentrant on ALL functions sharing state
function withdraw() public nonReentrant { ... }
function transfer(address to, uint amt) public nonReentrant { ... }
```

**Real-World Example:** Rari Capital (2021-05) — Cross-contract reentrancy via shared state

---

### VP-03: Cross-Contract Reentrancy
**Classification:** SWC-107 variant | OWASP SC-08
**Severity:** Critical

**Detection Heuristics:**
- Contract A calls Contract B, which calls back into Contract A or Contract C
- Shared state across contracts not guarded by global lock
- Token transfers that trigger callbacks (ERC777, ERC721)

**Vulnerable Pattern:**
```solidity
// Contract A calls token.transfer which calls B.tokensReceived()
// B.tokensReceived() calls back into A before A updates state
function deposit(uint amount) external {
    token.transferFrom(msg.sender, address(this), amount);
    shares[msg.sender] += computeShares(amount); // too late if callback re-enters
}
```

**Fixed Pattern:**
```solidity
function deposit(uint amount) external nonReentrant {
    shares[msg.sender] += computeShares(amount); // update FIRST
    token.transferFrom(msg.sender, address(this), amount);
}
```

**Real-World Example:** Cream Finance (2021-08) — $18M via AMP token ERC777 callback

---

### VP-04: Read-Only Reentrancy
**Classification:** SWC-107 variant | OWASP SC-08
**Severity:** High
**Prevalence:** 5+ read-only reentrancy exploits in DeFiHackLabs

**Detection Heuristics:**
- A view/pure function returns state that is temporarily inconsistent during external call
- Another contract reads this view function during the callback window
- Price or share calculations depend on the inconsistent state

**Vulnerable Pattern:**
```solidity
// Pool's getRate() reads balances that are stale during callback
function remove_liquidity() external {
    // sends ETH (triggers callback) BEFORE updating balances
    msg.sender.call{value: ethAmount}("");
    totalSupply -= shares; // balance still stale during callback
}
function getRate() external view returns (uint) {
    return address(this).balance / totalSupply; // wrong during callback!
}
```

**Fixed Pattern:**
```solidity
// Use a reentrancy lock that also blocks view functions
// Or update accounting before any external interactions
function remove_liquidity() external nonReentrant {
    totalSupply -= shares; // update first
    msg.sender.call{value: ethAmount}("");
}
```

**Real-World Example:** Sentiment (2023-04) — $1M — Balancer pool read-only reentrancy

---

### VP-05: ERC777 / ERC721 Callback Reentrancy
**Classification:** SWC-107 variant | OWASP SC-08
**Severity:** High

**Detection Heuristics:**
- Contract interacts with ERC777 tokens (`tokensReceived` hook)
- Contract uses `safeTransferFrom` / `safeMint` for ERC721 (`onERC721Received` hook)
- No reentrancy guard on functions calling these

**Vulnerable Pattern:**
```solidity
function mint() public payable {
    require(msg.value >= price);
    _safeMint(msg.sender, nextId++); // triggers onERC721Received callback
    totalMinted++; // state update after callback
}
```

**Fixed Pattern:**
```solidity
function mint() public payable nonReentrant {
    require(msg.value >= price);
    totalMinted++;
    _safeMint(msg.sender, nextId++);
}
```

**Real-World Example:** LendfMe (2020-04) — $25M — ERC777 imBTC reentrancy

---

## Category 2: Access Control

### VP-06: Missing Access Control Modifier
**Classification:** SWC-105 | OWASP SC-01 | Cyfrin SOL-AM-AA
**Severity:** Critical
**Prevalence:** 76+ access control exploits in DeFiHackLabs (11%)

**Detection Heuristics:**
- State-changing functions without `onlyOwner`, `onlyRole`, or `require(msg.sender == ...)` checks
- Functions that modify balances, ownership, or configuration without authorization
- `public` or `external` functions that should be `internal` or have a modifier

**Vulnerable Pattern:**
```solidity
function changeOwner(address newOwner) public {
    owner = newOwner; // anyone can call!
}
```

**Fixed Pattern:**
```solidity
function changeOwner(address newOwner) public onlyOwner {
    owner = newOwner;
}
```

**Real-World Example:** Parity Wallet (2017-07) — $31M — `initWallet` callable by anyone

---

### VP-07: tx.origin Authentication
**Classification:** SWC-115 | OWASP SC-01
**Severity:** High

**Detection Heuristics:**
- `require(tx.origin == owner)` or any use of `tx.origin` for authorization
- `tx.origin` used in access control checks instead of `msg.sender`

**Vulnerable Pattern:**
```solidity
function transferTo(address to, uint amount) public {
    require(tx.origin == owner); // phishable!
    payable(to).transfer(amount);
}
```

**Fixed Pattern:**
```solidity
function transferTo(address to, uint amount) public {
    require(msg.sender == owner);
    payable(to).transfer(amount);
}
```

**Real-World Example:** Common in early smart contracts; phishing attack vector via malicious contract calls

---

### VP-08: Unsafe Delegatecall
**Classification:** SWC-112 | OWASP SC-01
**Severity:** Critical

**Detection Heuristics:**
- `delegatecall` with user-controllable target address
- `delegatecall` to untrusted callee contract
- Storage layout mismatch between proxy and implementation

**Vulnerable Pattern:**
```solidity
function forward(address callee, bytes calldata data) public {
    (bool ok,) = callee.delegatecall(data); // attacker controls callee!
    require(ok);
}
```

**Fixed Pattern:**
```solidity
// Only delegatecall to trusted, immutable implementation addresses
// Never allow user-specified delegatecall targets
address public immutable implementation;
function forward(bytes calldata data) public {
    (bool ok,) = implementation.delegatecall(data);
    require(ok);
}
```

**Real-World Example:** Poly Network (2021-08) — $611M — delegatecall modifier bypass

---

### VP-09: Unprotected Initializer
**Classification:** SWC-118 variant | OWASP SC-01
**Severity:** Critical

**Detection Heuristics:**
- `initialize()` function without `initializer` modifier (OpenZeppelin)
- Implementation contract (not proxy) can be initialized by attacker
- `initialize()` callable more than once
- Missing `_disableInitializers()` in constructor of implementation

**Vulnerable Pattern:**
```solidity
function initialize(address _owner) public {
    owner = _owner; // no guard against re-initialization
}
```

**Fixed Pattern:**
```solidity
constructor() { _disableInitializers(); }
function initialize(address _owner) public initializer {
    __Ownable_init(_owner);
}
```

**Real-World Example:** Harvest Finance implementation takeover — uninitialized impl contracts

---

### VP-10: Default Function Visibility
**Classification:** SWC-100 | Cyfrin SOL-CQ-DV
**Severity:** Medium

**Detection Heuristics:**
- Functions without explicit `public`/`external`/`internal`/`private` keyword (Solidity <0.5.0)
- Sensitive functions that default to `public` visibility
- `internal` helper functions accidentally left `public`

**Vulnerable Pattern:**
```solidity
// Solidity <0.5.0: defaults to public
function _internalHelper() { ... }
```

**Fixed Pattern:**
```solidity
function _internalHelper() internal { ... }
```

**Real-World Example:** Parity Wallet (2017-07) — library's `initWallet` had public visibility

---

### VP-11: Self-Destruct Authorization
**Classification:** SWC-106 | OWASP SC-01
**Severity:** Critical

**Detection Heuristics:**
- `selfdestruct` with insufficient access control
- Missing multi-sig requirement on destructive operations
- Force-sending ETH via `selfdestruct` to break contract invariants

**Vulnerable Pattern:**
```solidity
function destroy() public {
    selfdestruct(payable(owner)); // any logic bug in owner assignment = loss
}
```

**Fixed Pattern:**
```solidity
// Avoid selfdestruct entirely (deprecated in EIP-6049)
// If needed, use multi-sig + timelock
function destroy() public onlyMultisig timelocked(48 hours) {
    selfdestruct(payable(treasury));
}
```

**Real-World Example:** Parity Wallet (2017-11) — 514K ETH locked forever via accidental selfdestruct of library

---

## Category 3: Arithmetic

### VP-12: Integer Overflow / Underflow
**Classification:** SWC-101 | OWASP SC-07
**Severity:** High

**Detection Heuristics:**
- `unchecked { }` blocks with arithmetic on user-controlled values
- Solidity <0.8.0 without SafeMath
- Token amount calculations inside `unchecked` blocks

**Vulnerable Pattern:**
```solidity
// Solidity <0.8.0 or inside unchecked block
uint8 balance = 255;
balance += 1; // wraps to 0
```

**Fixed Pattern:**
```solidity
// Use Solidity >=0.8.0 (built-in overflow checks)
// Or explicit bounds checking in unchecked blocks
unchecked {
    require(balance + amount >= balance, "overflow");
    balance += amount;
}
```

**Real-World Example:** Beauty Chain (2018-04) — $900M — batchOverflow integer overflow

---

### VP-13: Precision Loss (Divide Before Multiply)
**Classification:** SWC-101 variant | OWASP SC-07
**Severity:** Medium
**Prevalence:** 7+ precision loss exploits in DeFiHackLabs

**Detection Heuristics:**
- Division operation followed by multiplication: `(a / b) * c`
- Integer division truncating to zero: `smallNum / largeNum == 0`
- Token price calculations without scaling factors

**Vulnerable Pattern:**
```solidity
// Division before multiplication loses precision
uint result = (amount / totalSupply) * price;
// If amount < totalSupply, result = 0
```

**Fixed Pattern:**
```solidity
// Multiply first, then divide
uint result = (amount * price) / totalSupply;
// Or use fixed-point math library
```

**Real-World Example:** KyberSwap (2023-11) — $48M — precision loss in tick math

---

### VP-14: Unsafe Downcast
**Classification:** SWC-101 variant | OWASP SC-07
**Severity:** Medium

**Detection Heuristics:**
- Casting `uint256` to smaller type: `uint128(value)`, `uint96(value)`, etc.
- No range check before downcast
- Token amounts or timestamps cast to smaller types

**Vulnerable Pattern:**
```solidity
uint256 bigValue = type(uint256).max;
uint128 smallValue = uint128(bigValue); // silent truncation!
```

**Fixed Pattern:**
```solidity
uint256 bigValue = type(uint256).max;
require(bigValue <= type(uint128).max, "overflow");
uint128 smallValue = uint128(bigValue);
// Or use SafeCast library
```

**Real-World Example:** Poolz (2023-03) — $390K — integer overflow via unsafe cast

---

### VP-15: Rounding Exploitation
**Classification:** OWASP SC-07
**Severity:** Medium

**Detection Heuristics:**
- Share/token minting with division: `shares = amount / pricePerShare`
- Rounding direction favors user over protocol
- Repeated small transactions to accumulate rounding errors

**Vulnerable Pattern:**
```solidity
function deposit(uint amount) external {
    uint shares = amount * totalShares / totalAssets; // rounds DOWN
    // Attacker deposits 1 wei repeatedly, accumulating free shares
}
```

**Fixed Pattern:**
```solidity
function deposit(uint amount) external {
    // Round DOWN for deposits (against user), UP for withdrawals (against user)
    uint shares = amount.mulDivDown(totalShares, totalAssets);
    require(shares > 0, "zero shares");
}
```

**Real-World Example:** Hundred Finance (2023-04) — $7M — donation + rounding attack

---

### VP-16: Off-By-One Errors
**Classification:** Cyfrin SOL-AM-OBO | kadenzipfel off-by-one
**Severity:** Low to Medium

**Detection Heuristics:**
- Loop bounds using `<` vs `<=` or vice versa
- Array indexing starting from wrong offset
- Fence-post errors in time/block calculations

**Vulnerable Pattern:**
```solidity
// Skips last element
for (uint i = 0; i < users.length - 1; i++) {
    distribute(users[i]);
}
```

**Fixed Pattern:**
```solidity
for (uint i = 0; i < users.length; i++) {
    distribute(users[i]);
}
```

**Real-World Example:** Common in reward distribution loops — often found in audits

---

## Category 4: Oracle / Price Manipulation

### VP-17: Spot Price Manipulation
**Classification:** OWASP SC-03 | Cyfrin SOL-AM-PM
**Severity:** Critical
**Prevalence:** 152+ price/oracle manipulation exploits in DeFiHackLabs (22%)

**Detection Heuristics:**
- Using `balanceOf()` or AMM reserve ratios for price calculation
- Using `getReserves()` as a price oracle
- Price derived from single DEX pool without TWAP
- No minimum liquidity requirements

**Vulnerable Pattern:**
```solidity
function getPrice() public view returns (uint) {
    (uint r0, uint r1,) = pair.getReserves();
    return r0 * 1e18 / r1; // manipulable in a single tx!
}
```

**Fixed Pattern:**
```solidity
function getPrice() public view returns (uint) {
    // Use Chainlink oracle or TWAP
    (, int price,, uint updatedAt,) = priceFeed.latestRoundData();
    require(block.timestamp - updatedAt < STALENESS_THRESHOLD);
    require(price > 0);
    return uint(price);
}
```

**Real-World Example:** Mango Markets (2022-10) — $114M — spot price manipulation of MNGO token

---

### VP-18: Stale Chainlink Price Feed
**Classification:** OWASP SC-03 | Cyfrin SOL-AM-SO
**Severity:** High

**Detection Heuristics:**
- `latestRoundData()` without checking `updatedAt` timestamp
- Missing `answeredInRound >= roundId` check
- No staleness threshold (heartbeat check)
- Missing `price > 0` check

**Vulnerable Pattern:**
```solidity
(, int price,,,) = priceFeed.latestRoundData();
return uint(price); // could be stale or zero!
```

**Fixed Pattern:**
```solidity
(uint80 roundId, int price,, uint updatedAt, uint80 answeredInRound) =
    priceFeed.latestRoundData();
require(price > 0, "invalid price");
require(updatedAt > 0, "round not complete");
require(answeredInRound >= roundId, "stale price");
require(block.timestamp - updatedAt < HEARTBEAT, "stale");
```

**Real-World Example:** BonqDAO (2023-02) — $88M — price oracle manipulation via stale feed

---

### VP-19: Insufficient TWAP Window
**Classification:** OWASP SC-03
**Severity:** High

**Detection Heuristics:**
- TWAP window shorter than 30 minutes
- Single-block TWAP (essentially spot price)
- No multi-oracle fallback

**Vulnerable Pattern:**
```solidity
// 1-block TWAP = essentially spot price, easily manipulable
uint twapPrice = oracle.consult(token, 1 /* 1 block window */);
```

**Fixed Pattern:**
```solidity
// Use at least 30-minute TWAP window
uint twapPrice = oracle.consult(token, 1800 /* 30 min window */);
// Also verify against Chainlink as secondary oracle
```

**Real-World Example:** Rodeo Finance (2023-07) — $888K — TWAP oracle manipulation

---

### VP-20: Flash Loan Oracle Manipulation
**Classification:** OWASP SC-03 + SC-04
**Severity:** Critical

**Detection Heuristics:**
- Governance voting power based on token balance (not checkpoint)
- Collateral valuation using spot price
- Any price-dependent logic executable in same tx as large swap

**Vulnerable Pattern:**
```solidity
function getVotingPower(address user) public view returns (uint) {
    return token.balanceOf(user); // flash-loanable!
}
```

**Fixed Pattern:**
```solidity
function getVotingPower(address user) public view returns (uint) {
    return token.getPastVotes(user, block.number - 1); // checkpoint-based
}
```

**Real-World Example:** Beanstalk (2022-04) — $182M — flash loan governance attack

---

### VP-21: Sandwich Attack Vulnerability
**Classification:** OWASP SC-03 | MEV
**Severity:** Medium

**Detection Heuristics:**
- AMM swaps without slippage protection (`amountOutMin = 0`)
- Missing deadline parameter in swap calls
- Large swaps without private mempool

**Vulnerable Pattern:**
```solidity
router.swapExactTokensForTokens(
    amountIn, 0 /* no slippage protection */, path, to, block.timestamp
);
```

**Fixed Pattern:**
```solidity
router.swapExactTokensForTokens(
    amountIn, expectedOut * 99 / 100 /* 1% slippage */, path, to,
    block.timestamp + 300 /* 5 min deadline */
);
```

**Real-World Example:** Common MEV extraction — billions extracted via sandwich attacks across DeFi

---

## Category 5: Input Validation

### VP-22: Missing Zero-Address Check
**Classification:** SWC-125 variant | OWASP SC-05
**Severity:** Medium

**Detection Heuristics:**
- Constructor or initializer setting `owner`, `admin`, or `treasury` without `!= address(0)` check
- `setFeeRecipient` type functions without zero check
- Critical address parameters in any setter function

**Vulnerable Pattern:**
```solidity
function setTreasury(address _treasury) external onlyOwner {
    treasury = _treasury; // could be address(0), locking funds forever
}
```

**Fixed Pattern:**
```solidity
function setTreasury(address _treasury) external onlyOwner {
    require(_treasury != address(0), "zero address");
    treasury = _treasury;
}
```

**Real-World Example:** Multiple incidents where funds sent to address(0) were permanently lost

---

### VP-23: Missing Amount Validation
**Classification:** OWASP SC-05
**Severity:** Low to Medium

**Detection Heuristics:**
- Functions accepting `uint amount` without `require(amount > 0)`
- Division by amount that could be zero
- Token transfers of 0 amount creating empty events

**Vulnerable Pattern:**
```solidity
function stake(uint amount) external {
    token.transferFrom(msg.sender, address(this), amount); // amount could be 0
    shares[msg.sender] += totalShares * amount / totalStaked; // div by zero if empty
}
```

**Fixed Pattern:**
```solidity
function stake(uint amount) external {
    require(amount > 0, "zero amount");
    require(totalStaked > 0 || amount >= MIN_STAKE, "min stake");
    ...
}
```

---

### VP-24: Array Length Mismatch
**Classification:** OWASP SC-05
**Severity:** Medium

**Detection Heuristics:**
- Functions taking multiple arrays as parameters without length equality check
- Batch operations iterating over one array with index from another

**Vulnerable Pattern:**
```solidity
function batchTransfer(address[] calldata to, uint[] calldata amounts) external {
    for (uint i = 0; i < to.length; i++) {
        transfer(to[i], amounts[i]); // OOB if arrays different length
    }
}
```

**Fixed Pattern:**
```solidity
function batchTransfer(address[] calldata to, uint[] calldata amounts) external {
    require(to.length == amounts.length, "length mismatch");
    for (uint i = 0; i < to.length; i++) {
        transfer(to[i], amounts[i]);
    }
}
```

---

### VP-25: msg.value in Loop
**Classification:** kadenzipfel msgvalue-loop | Cyfrin SOL-CF-MVL
**Severity:** High

**Detection Heuristics:**
- `msg.value` checked or used inside a `for` or `while` loop
- Same `msg.value` credited multiple times across iterations
- Payable function iterating over user-provided array

**Vulnerable Pattern:**
```solidity
function batchBuy(uint[] calldata ids) external payable {
    for (uint i = 0; i < ids.length; i++) {
        require(msg.value >= price); // SAME msg.value checked each iteration!
        _mint(msg.sender, ids[i]);
    }
}
```

**Fixed Pattern:**
```solidity
function batchBuy(uint[] calldata ids) external payable {
    require(msg.value >= price * ids.length, "insufficient payment");
    for (uint i = 0; i < ids.length; i++) {
        _mint(msg.sender, ids[i]);
    }
}
```

**Real-World Example:** Opyn Protocol (2020-08) — msg.value reuse in loop

---

## Category 6: Unchecked Returns

### VP-26: Unchecked ERC20 Transfer
**Classification:** SWC-104 | OWASP SC-06 | Cyfrin SOL-AM-URV
**Severity:** High

**Detection Heuristics:**
- `token.transfer()` or `token.transferFrom()` without checking return value
- Not using `SafeERC20.safeTransfer` / `safeTransferFrom`
- Tokens like USDT that don't return `bool`

**Vulnerable Pattern:**
```solidity
token.transfer(recipient, amount); // return value ignored!
// USDT: doesn't return bool at all — always reverts as "false"
```

**Fixed Pattern:**
```solidity
// Use OpenZeppelin SafeERC20
using SafeERC20 for IERC20;
token.safeTransfer(recipient, amount);
```

**Real-World Example:** Multiple DeFi protocols lost funds by not handling USDT's non-standard return

---

### VP-27: Unchecked Low-Level Call
**Classification:** SWC-104 | OWASP SC-06
**Severity:** High

**Detection Heuristics:**
- `.call{value:}()` without checking the `bool` return value
- `.send()` return value ignored
- `.delegatecall()` return value not checked

**Vulnerable Pattern:**
```solidity
payable(recipient).send(amount); // returns false on failure, not checked!
```

**Fixed Pattern:**
```solidity
(bool success,) = payable(recipient).call{value: amount}("");
require(success, "transfer failed");
```

---

### VP-28: Unchecked Create / Create2
**Classification:** SWC-104 variant
**Severity:** Medium

**Detection Heuristics:**
- `new Contract()` without checking returned address is non-zero
- `create2` assembly without success check
- Factory patterns without deployment verification

**Vulnerable Pattern:**
```solidity
address deployed;
assembly { deployed := create2(0, add(code, 0x20), mload(code), salt) }
// deployed could be address(0) if creation failed
```

**Fixed Pattern:**
```solidity
address deployed;
assembly { deployed := create2(0, add(code, 0x20), mload(code), salt) }
require(deployed != address(0), "deployment failed");
```

---

## Category 7: Denial of Service

### VP-29: Unbounded Loop / Block Gas Limit
**Classification:** SWC-128 | OWASP SC-09 | Cyfrin SOL-AM-DOSA
**Severity:** High

**Detection Heuristics:**
- Loops iterating over arrays that grow with user actions
- `for (uint i = 0; i < users.length; i++)` where `users` is unbounded
- `while` loops without gas-aware breaking

**Vulnerable Pattern:**
```solidity
function distributeRewards() external {
    for (uint i = 0; i < stakers.length; i++) { // could be 10,000+
        token.transfer(stakers[i], rewards[i]);
    }
}
```

**Fixed Pattern:**
```solidity
// Use pull pattern instead of push
mapping(address => uint) public pendingRewards;
function claimReward() external {
    uint reward = pendingRewards[msg.sender];
    pendingRewards[msg.sender] = 0;
    token.safeTransfer(msg.sender, reward);
}
```

**Real-World Example:** GovernorBravo proposals with many voters can exceed block gas limit

---

### VP-30: DoS via Unexpected Revert
**Classification:** SWC-113 | OWASP SC-09
**Severity:** High

**Detection Heuristics:**
- Batch ETH sends where one revert blocks all (push pattern)
- External calls in loops without try/catch
- Functions that `require` success of every sub-operation

**Vulnerable Pattern:**
```solidity
function payAll() external {
    for (uint i = 0; i < payees.length; i++) {
        // If one payee is a contract that reverts, ALL payments fail
        payable(payees[i]).transfer(amounts[i]);
    }
}
```

**Fixed Pattern:**
```solidity
// Pull pattern: let users withdraw individually
function withdraw() external {
    uint amount = owed[msg.sender];
    owed[msg.sender] = 0;
    payable(msg.sender).transfer(amount);
}
```

**Real-World Example:** King of the Ether — contract refund blocked by reverting fallback

---

### VP-31: Selfdestruct Force-Send
**Classification:** SWC-132 | OWASP SC-09
**Severity:** Medium

**Detection Heuristics:**
- Contract logic depends on `address(this).balance` for calculations
- Invariant assumes balance only changes via payable functions
- `selfdestruct` can force-send ETH bypassing all receive/fallback logic

**Vulnerable Pattern:**
```solidity
function isGameOver() public view returns (bool) {
    return address(this).balance >= targetAmount; // manipulable!
}
```

**Fixed Pattern:**
```solidity
uint public totalDeposited; // track deposits explicitly
function isGameOver() public view returns (bool) {
    return totalDeposited >= targetAmount;
}
```

---

### VP-32: Insufficient Gas Griefing
**Classification:** SWC-126 | kadenzipfel insufficient-gas-griefing
**Severity:** Medium

**Detection Heuristics:**
- Relayer/forwarder patterns where the outer call succeeds but inner call fails
- `call` without specifying gas or checking `gasleft()`
- Meta-transaction relayers not forwarding sufficient gas

**Vulnerable Pattern:**
```solidity
function relay(address target, bytes calldata data) external {
    (bool ok,) = target.call(data); // relayer can provide insufficient gas
    // ok is false but relay "succeeds"
}
```

**Fixed Pattern:**
```solidity
function relay(address target, bytes calldata data, uint minGas) external {
    require(gasleft() >= minGas + 5000, "insufficient gas");
    (bool ok,) = target.call{gas: minGas}(data);
    require(ok, "call failed");
}
```

---

### VP-33: Unbounded Return Data
**Classification:** kadenzipfel unbounded-return-data
**Severity:** Medium

**Detection Heuristics:**
- Low-level `.call()` to untrusted address stores return data in memory
- Return data size not bounded, causing memory expansion gas costs
- `abi.decode` on untrusted return data

**Vulnerable Pattern:**
```solidity
(bool ok, bytes memory data) = untrusted.call(payload);
// Untrusted contract returns megabytes, consuming all gas in memory expansion
```

**Fixed Pattern:**
```solidity
// Use assembly to limit return data size
assembly {
    let ok := call(gas(), target, 0, add(payload, 0x20), mload(payload), 0, 0)
    returndatacopy(0, 0, min(returndatasize(), 256)) // cap at 256 bytes
}
```

---

## Category 8: Logic Errors

### VP-34: Front-Running / Transaction Ordering Dependence
**Classification:** SWC-114 | OWASP SC-05
**Severity:** Medium to High

**Detection Heuristics:**
- `approve()` calls without first setting to 0 (ERC20 approval race)
- State-changing operations where order matters and mempool is visible
- First-come-first-served patterns without commit-reveal

**Vulnerable Pattern:**
```solidity
// Approval race: owner approves 100, attacker front-runs to spend old 50,
// then spends new 100 = 150 total
token.approve(spender, newAmount);
```

**Fixed Pattern:**
```solidity
// Set to 0 first, or use increaseAllowance/decreaseAllowance
token.approve(spender, 0);
token.approve(spender, newAmount);
// Better: use permit() or increaseAllowance()
```

---

### VP-35: Timestamp Dependence
**Classification:** SWC-116 | kadenzipfel timestamp-dependence
**Severity:** Low

**Detection Heuristics:**
- `block.timestamp` used for random number generation
- Critical branching based on exact timestamp comparison
- Time-sensitive auctions relying solely on `block.timestamp`

**Vulnerable Pattern:**
```solidity
function isWinner() public view returns (bool) {
    return block.timestamp % 2 == 0; // miner-manipulable
}
```

**Fixed Pattern:**
```solidity
// Use Chainlink VRF for randomness
// For time-dependent logic, use generous windows (>15 min)
function isExpired() public view returns (bool) {
    return block.timestamp > deadline; // OK if deadline has generous buffer
}
```

---

### VP-36: Signature Replay Attack
**Classification:** SWC-121 | Cyfrin SOL-AM-SRA
**Severity:** High

**Detection Heuristics:**
- Signature verification without nonce
- Missing `chainId` in signed message (cross-chain replay)
- Missing contract address in signed message (cross-contract replay)
- No mechanism to invalidate used signatures

**Vulnerable Pattern:**
```solidity
function execute(bytes calldata sig, address to, uint amount) external {
    bytes32 hash = keccak256(abi.encodePacked(to, amount));
    address signer = ECDSA.recover(hash, sig);
    require(signer == owner);
    // Same signature reusable forever!
}
```

**Fixed Pattern:**
```solidity
mapping(bytes32 => bool) public usedSigs;
function execute(bytes calldata sig, address to, uint amount, uint nonce) external {
    bytes32 hash = keccak256(abi.encodePacked(
        address(this), block.chainid, to, amount, nonce
    ));
    require(!usedSigs[hash], "replay");
    address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), sig);
    require(signer == owner);
    usedSigs[hash] = true;
}
```

**Real-World Example:** Minto Finance (2023-07) — $9K — signature replay

---

### VP-37: Signature Malleability
**Classification:** SWC-117 | Cyfrin SOL-AM-SM
**Severity:** Medium

**Detection Heuristics:**
- Using `ecrecover` directly instead of ECDSA library
- Signature uniqueness enforced by hashing the signature itself
- Not checking `s` value is in lower half of secp256k1 order

**Vulnerable Pattern:**
```solidity
// Signature hash used as unique ID — malleable!
bytes32 sigId = keccak256(sig);
require(!used[sigId]);
address signer = ecrecover(hash, v, r, s);
```

**Fixed Pattern:**
```solidity
// Use OpenZeppelin ECDSA which normalizes s-value
address signer = ECDSA.recover(hash, sig); // rejects malleable sigs
// Use message hash as unique ID, not signature hash
require(!usedHashes[hash]);
usedHashes[hash] = true;
```

---

### VP-38: Hash Collision with abi.encodePacked
**Classification:** SWC-133 | kadenzipfel hash-collision
**Severity:** Medium

**Detection Heuristics:**
- `abi.encodePacked()` with multiple dynamic-length arguments (string, bytes)
- Hash used for access control or signature verification

**Vulnerable Pattern:**
```solidity
// abi.encodePacked("ab", "c") == abi.encodePacked("a", "bc")
bytes32 hash = keccak256(abi.encodePacked(stringA, stringB));
```

**Fixed Pattern:**
```solidity
// Use abi.encode() for unambiguous encoding
bytes32 hash = keccak256(abi.encode(stringA, stringB));
```

---

### VP-39: Storage Collision (Proxy Pattern)
**Classification:** SWC-124 | Cyfrin SOL-AM-SC
**Severity:** Critical

**Detection Heuristics:**
- Proxy contract and implementation have different storage variable order
- New variables added to beginning/middle of upgraded implementation
- Inherited contracts change storage layout between versions

**Vulnerable Pattern:**
```solidity
// Implementation v1
contract V1 { uint public value; address public owner; }
// Implementation v2 — BREAKS storage layout
contract V2 { address public owner; uint public value; uint public newVar; }
```

**Fixed Pattern:**
```solidity
// Append-only storage: new variables always at the end
contract V2 { uint public value; address public owner; uint public newVar; }
// Or use EIP-1967 storage slots for proxy-specific variables
```

**Real-World Example:** EFVault (2023-02) — $5.1M — storage collision in proxy upgrade

---

### VP-40: Weak Randomness
**Classification:** SWC-120 | kadenzipfel weak-sources-randomness
**Severity:** Medium to High

**Detection Heuristics:**
- `block.timestamp`, `block.number`, `blockhash` used for randomness
- `keccak256(abi.encodePacked(block.difficulty, block.timestamp))` pattern
- Any on-chain-only RNG in high-value contexts

**Vulnerable Pattern:**
```solidity
uint random = uint(keccak256(abi.encodePacked(
    block.timestamp, block.difficulty, msg.sender
)));
```

**Fixed Pattern:**
```solidity
// Use Chainlink VRF for verifiable randomness
uint requestId = COORDINATOR.requestRandomWords(...);
// Fulfill in separate callback transaction
```

---

### VP-41: Struct / Array Deletion Oversight
**Classification:** DeFiVulnLabs Struct-deletion / Array-deletion
**Severity:** Medium

**Detection Heuristics:**
- `delete structVar` where struct contains a mapping (mapping data persists)
- `delete array[index]` leaves a gap (zero element, doesn't shift)
- Missing cleanup of nested data structures

**Vulnerable Pattern:**
```solidity
struct User { uint balance; mapping(uint => uint) history; }
mapping(address => User) users;
delete users[addr]; // mapping inside struct NOT deleted!
```

**Fixed Pattern:**
```solidity
// Manually clear mapping entries before deleting struct
// Or use a separate tracking mechanism for mapping keys
for (uint i = 0; i < keys.length; i++) {
    delete users[addr].history[keys[i]];
}
delete users[addr];
```

---

## Category 9: Upgrade Safety

### VP-42: Uninitialized Implementation Contract
**Classification:** OWASP SC-10 | Cyfrin SOL-AM-UIV
**Severity:** Critical

**Detection Heuristics:**
- UUPS/Transparent proxy pattern
- Implementation contract missing `_disableInitializers()` in constructor
- Implementation's `initialize()` callable directly (not through proxy)

**Vulnerable Pattern:**
```solidity
contract MyToken is UUPSUpgradeable {
    // Constructor does NOT disable initializers
    function initialize() public initializer { ... }
}
```

**Fixed Pattern:**
```solidity
contract MyToken is UUPSUpgradeable {
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() { _disableInitializers(); }
    function initialize() public initializer { ... }
}
```

---

### VP-43: Storage Layout Violation in Upgrade
**Classification:** OWASP SC-10
**Severity:** Critical

**Detection Heuristics:**
- New version inserts variables before existing ones
- Variable type changed between versions
- Inherited contract order changed between versions

**Vulnerable Pattern:**
```solidity
// V1: slot 0 = value, slot 1 = owner
// V2: slot 0 = newVar (BREAKS value and owner!)
contract V2 is UUPSUpgradeable {
    uint public newVar; // inserted before existing vars
    uint public value;
    address public owner;
}
```

**Fixed Pattern:**
```solidity
// Always append new variables at the end
// Use storage gaps: uint256[50] private __gap;
contract V2 is UUPSUpgradeable {
    uint public value;
    address public owner;
    uint256[48] private __gap; // reduced by 1 for newVar
    uint public newVar; // appended at end
}
```

---

### VP-44: Missing Reinitializer Guard
**Classification:** OWASP SC-10
**Severity:** High

**Detection Heuristics:**
- Upgraded contract needs to initialize new state
- Using `initializer` modifier instead of `reinitializer(N)`
- No version tracking across upgrades

**Vulnerable Pattern:**
```solidity
// V2 tries to set new state but initializer already ran for V1
function initialize() public initializer { /* can't run again */ }
function initializeV2(address newParam) public { /* no guard! */ }
```

**Fixed Pattern:**
```solidity
function initializeV2(address newParam) public reinitializer(2) {
    newState = newParam;
}
```

---

### VP-45: Function Selector Clashing in Proxy
**Classification:** OWASP SC-10
**Severity:** Medium

**Detection Heuristics:**
- Transparent proxy with admin functions that share selectors with implementation functions
- `collisions()` check not performed on upgrade
- Custom proxy with `fallback()` that doesn't properly delegate

**Vulnerable Pattern:**
```solidity
// Proxy has admin() at selector 0xf851a440
// Implementation adds a function with same selector
// Calls get routed to wrong function depending on caller
```

**Fixed Pattern:**
```solidity
// Use OpenZeppelin TransparentUpgradeableProxy (routes by caller)
// Or UUPS pattern (no function clashing possible)
// Always run selector collision check before upgrade
```

---

## Category 10: Token Integration

### VP-46: Fee-on-Transfer Token
**Classification:** DeFiVulnLabs fee-on-transfer | Cyfrin SOL-AM-FOT
**Severity:** High

**Detection Heuristics:**
- `transferFrom` amount assumed to equal received amount
- No balance check before/after transfer
- Tokens like USDT with potential fee, STA, PAXG

**Vulnerable Pattern:**
```solidity
function deposit(uint amount) external {
    token.transferFrom(msg.sender, address(this), amount);
    balances[msg.sender] += amount; // actual received < amount for fee tokens!
}
```

**Fixed Pattern:**
```solidity
function deposit(uint amount) external {
    uint before = token.balanceOf(address(this));
    token.safeTransferFrom(msg.sender, address(this), amount);
    uint received = token.balanceOf(address(this)) - before;
    balances[msg.sender] += received;
}
```

---

### VP-47: Rebasing Token
**Classification:** Cyfrin SOL-AM-RT
**Severity:** Medium

**Detection Heuristics:**
- Token balances change without transfers (e.g., stETH, AMPL, OHM)
- Contract caches token balance and uses it later
- Share-based accounting not used for rebasing tokens

**Vulnerable Pattern:**
```solidity
// Balance cached, then rebase happens, cached value is stale
uint balance = token.balanceOf(address(this));
// ... time passes, rebase occurs ...
token.transfer(user, balance); // may fail or transfer wrong amount
```

**Fixed Pattern:**
```solidity
// Use wstETH (non-rebasing wrapper) instead of stETH
// Or use share-based accounting
// Or read balance fresh before every use
```

---

### VP-48: ERC20 Missing Return Bool
**Classification:** SWC-104 variant | DeFiVulnLabs Returnvalue/Returnfalse
**Severity:** Medium

**Detection Heuristics:**
- Direct `token.transfer()` call without SafeERC20 wrapper
- Tokens like USDT, BNB that don't return `bool`
- `bool success = token.transfer(...)` fails to compile with non-standard tokens

**Vulnerable Pattern:**
```solidity
IERC20(token).transfer(to, amount); // USDT: no return value, causes revert
```

**Fixed Pattern:**
```solidity
using SafeERC20 for IERC20;
IERC20(token).safeTransfer(to, amount); // handles non-standard returns
```

---

### VP-49: Approval Race Condition
**Classification:** SWC-114 variant
**Severity:** Medium

**Detection Heuristics:**
- `approve(spender, newAmount)` without first setting to 0
- No use of `increaseAllowance` / `decreaseAllowance` pattern

**Vulnerable Pattern:**
```solidity
// User changes allowance from 100 to 50
// Spender front-runs: spends 100, then spends new 50 = 150 total
token.approve(spender, 50);
```

**Fixed Pattern:**
```solidity
token.approve(spender, 0); // reset first
token.approve(spender, 50);
// Or use SafeERC20.forceApprove()
```

---

### VP-50: ERC777 Hook Abuse
**Classification:** DeFiVulnLabs ERC777-reentrancy
**Severity:** High

**Detection Heuristics:**
- Contract receives ERC777 tokens (registered in ERC1820)
- `tokensReceived` hook not accounted for in token flow
- Missing reentrancy guard on functions receiving ERC777

**Vulnerable Pattern:**
```solidity
// ERC777 token transfer triggers tokensReceived() on recipient
// If recipient is a contract, it can re-enter before state updates
function deposit(uint amount) external {
    token.transferFrom(msg.sender, address(this), amount); // hook fires!
    balances[msg.sender] += amount; // state update after hook
}
```

**Fixed Pattern:**
```solidity
function deposit(uint amount) external nonReentrant {
    balances[msg.sender] += amount; // update state first
    token.transferFrom(msg.sender, address(this), amount);
}
```

**Real-World Example:** UniSwap V1 (2020-04) — $220K — imBTC ERC777 reentrancy

---

### VP-51: Self-Transfer Bypass
**Classification:** DeFiVulnLabs self-transfer
**Severity:** Medium

**Detection Heuristics:**
- Transfer function doesn't check `from == to`
- Balance update order: `balances[from] -= amount; balances[to] += amount;`
- When from == to, subtraction then addition can create tokens

**Vulnerable Pattern:**
```solidity
function transfer(address to, uint amount) public {
    balances[msg.sender] -= amount;
    balances[to] += amount; // if to == msg.sender, net effect is +amount!
}
```

**Fixed Pattern:**
```solidity
function transfer(address to, uint amount) public {
    require(to != msg.sender, "self-transfer");
    balances[msg.sender] -= amount;
    balances[to] += amount;
}
```

---

## Category 11: Flash Loan Attacks

### VP-52: Flash Loan Governance Attack
**Classification:** OWASP SC-04
**Severity:** Critical

**Detection Heuristics:**
- Governance voting power based on current token balance
- No snapshot/checkpoint mechanism for voting
- Proposals executable in same block as vote

**Vulnerable Pattern:**
```solidity
function vote(uint proposalId) external {
    uint power = token.balanceOf(msg.sender); // flash-loanable!
    proposals[proposalId].votes += power;
}
```

**Fixed Pattern:**
```solidity
function vote(uint proposalId) external {
    uint power = token.getPastVotes(msg.sender, proposals[proposalId].snapshotBlock);
    proposals[proposalId].votes += power;
}
```

**Real-World Example:** Beanstalk (2022-04) — $182M — flash loan + governance takeover

---

### VP-53: Flash Loan Collateral Manipulation
**Classification:** OWASP SC-04
**Severity:** Critical

**Detection Heuristics:**
- Collateral valuation using spot AMM price
- Borrow/mint/liquidation logic callable in same tx as price change
- No time-weighted or oracle-based collateral pricing

**Vulnerable Pattern:**
```solidity
function borrow(uint collateralAmount) external {
    uint collateralValue = getSpotPrice() * collateralAmount; // manipulable
    uint maxBorrow = collateralValue * LTV / 1e18;
    require(borrowAmount <= maxBorrow);
}
```

**Fixed Pattern:**
```solidity
function borrow(uint collateralAmount) external {
    uint collateralValue = chainlinkOracle.getPrice() * collateralAmount;
    // Or use TWAP with sufficient window
}
```

**Real-World Example:** Euler Finance (2023-03) — $197M — donate + borrow manipulation

---

### VP-54: Missing Flash Loan Initiator Check
**Classification:** DeFiVulnLabs Flashloan-flaw
**Severity:** High

**Detection Heuristics:**
- Flash loan callback doesn't verify `initiator == address(this)`
- Any address can trigger the callback via flash loan provider
- Missing validation in `onFlashLoan` / `executeOperation`

**Vulnerable Pattern:**
```solidity
function onFlashLoan(address initiator, ...) external returns (bytes32) {
    // No check on initiator!
    doSomethingDangerous();
    return keccak256("ERC3156FlashBorrower.onFlashLoan");
}
```

**Fixed Pattern:**
```solidity
function onFlashLoan(address initiator, ...) external returns (bytes32) {
    require(initiator == address(this), "unauthorized initiator");
    require(msg.sender == address(lender), "unauthorized lender");
    doSomethingDangerous();
    return keccak256("ERC3156FlashBorrower.onFlashLoan");
}
```

---

## Category 12: DeFi-Specific

### VP-55: Missing Slippage / Deadline Protection
**Classification:** DeFiVulnLabs Slippage-deadline | Cyfrin SOL-AM-MSP
**Severity:** High

**Detection Heuristics:**
- `amountOutMin = 0` in swap calls
- `deadline = block.timestamp` (always passes, useless)
- Hardcoded `type(uint256).max` for deadline
- No slippage parameter in user-facing swap functions

**Vulnerable Pattern:**
```solidity
router.swapExactTokensForTokens(
    amountIn, 0, path, address(this), block.timestamp // no protection!
);
```

**Fixed Pattern:**
```solidity
router.swapExactTokensForTokens(
    amountIn,
    amountOutMin, // user-specified minimum
    path,
    address(this),
    deadline // user-specified future timestamp
);
```

**Real-World Example:** BabyDogeCoin (2023-06) — $135K — lack of slippage protection

---

### VP-56: Vault Share Inflation / First Depositor Attack
**Classification:** DeFiVulnLabs first-deposit | Cyfrin SOL-AM-FDA
**Severity:** High
**Prevalence:** 6+ donation/inflation attacks in DeFiHackLabs

**Detection Heuristics:**
- ERC4626 vault or similar share-based pool
- First deposit can be 1 wei
- Attacker can donate tokens directly to vault (inflating assets per share)
- `shares = assets * totalShares / totalAssets` with no minimum

**Vulnerable Pattern:**
```solidity
function deposit(uint assets) external returns (uint shares) {
    shares = totalSupply == 0 ? assets : assets * totalSupply / totalAssets();
    // Attacker: deposit 1 wei, donate 1000 tokens, next depositor gets 0 shares
    _mint(msg.sender, shares);
}
```

**Fixed Pattern:**
```solidity
function deposit(uint assets) external returns (uint shares) {
    if (totalSupply == 0) {
        shares = assets - MINIMUM_LIQUIDITY; // burn minimum shares
        _mint(address(0), MINIMUM_LIQUIDITY); // dead shares
    } else {
        shares = assets.mulDivDown(totalSupply, totalAssets());
    }
    require(shares > 0, "zero shares");
    _mint(msg.sender, shares);
}
```

**Real-World Example:** Raft.fi (2023-11) — $3.2M — donation + rounding attack

---

### VP-57: recoverERC20 Backdoor
**Classification:** DeFiVulnLabs recoverERC20
**Severity:** Medium

**Detection Heuristics:**
- `recoverERC20(address token, uint amount)` function in staking/reward contracts
- No check that `token != stakingToken` and `token != rewardsToken`
- Owner can withdraw user-deposited tokens via "recovery"

**Vulnerable Pattern:**
```solidity
function recoverERC20(address token, uint amount) external onlyOwner {
    IERC20(token).transfer(owner, amount); // can steal staked tokens!
}
```

**Fixed Pattern:**
```solidity
function recoverERC20(address token, uint amount) external onlyOwner {
    require(token != stakingToken, "cannot recover staking token");
    require(token != rewardsToken, "cannot recover rewards token");
    IERC20(token).transfer(owner, amount);
}
```

---

### VP-58: Transient Storage Misuse (EIP-1153)
**Classification:** DeFiVulnLabs TransientStorageMisuse
**Severity:** Medium

**Detection Heuristics:**
- `TSTORE` / `TLOAD` opcodes used for reentrancy locks
- Transient storage not cleared between external calls in same tx
- Callbacks can read/write transient storage set by caller

**Vulnerable Pattern:**
```solidity
// Transient storage lock set during callback can be read by attacker
assembly { tstore(LOCK_SLOT, 1) }
externalCall(); // callback reads LOCK_SLOT
assembly { tstore(LOCK_SLOT, 0) }
```

**Fixed Pattern:**
```solidity
// Use unique, unpredictable slot keys
// Clear transient storage immediately after use
// Don't rely on transient storage for security across external calls
```

---

## Appendix: Code Quality Patterns (Informational)

### VP-59: Floating Pragma
**Severity:** Informational — Use `pragma solidity 0.8.20;` not `^0.8.0`

### VP-60: Shadowing State Variables
**Severity:** Low — Child contract variable shadows parent; use different names

### VP-61: Incorrect Inheritance Order
**Severity:** Low — C3 linearization: most base-like to most derived (left to right)

### VP-62: Unencrypted Private Data On-Chain
**Severity:** Informational — `private` doesn't mean secret; all storage is readable via `eth_getStorageAt`

### VP-63: Asserting Contract from Code Size
**Severity:** Low — `extcodesize == 0` during constructor; use `msg.sender == tx.origin` or better approaches

---

## Quick Reference: Pattern Detection Priority

For a typical DeFi audit, prioritize checking in this order (by real-world exploit frequency):

| Priority | Category | Patterns | DeFiHackLabs % (681 incidents) |
|----------|----------|----------|-------------------------------|
| 1 | Business Logic Flaws | VP-34 to VP-41 | ~22% (140-155) |
| 2 | Price/Oracle Manipulation | VP-17 to VP-21 | ~15% (95-110) |
| 3 | Access Control | VP-06 to VP-11 | ~11% (70-80) |
| 4 | Reentrancy (all forms) | VP-01 to VP-05 | ~9% (55-65) |
| 5 | Input Validation | VP-22 to VP-25 | ~7% (45-55) |
| 6 | Flash Loan Attacks | VP-52 to VP-54 | ~7% (40-50) |
| 7 | Precision / Arithmetic | VP-12 to VP-16 | ~5% (35-40) |
| 8 | Arbitrary Calls / Token Integration | VP-46 to VP-51 | ~5% (30-35) |
| 9 | DeFi-Specific (slippage, inflation) | VP-55 to VP-58 | ~3% (15-25) |
| 10 | Unchecked Returns | VP-26 to VP-28 | ~2% |
| 11 | Bridge / Cross-chain | — | ~2% (10-15) |
| 12 | Upgrade Safety / DoS | VP-29 to VP-33, VP-42 to VP-45 | ~2% |
